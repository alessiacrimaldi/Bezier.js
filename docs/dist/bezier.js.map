{"version":3,"file":"bezier.js","sources":["../../lib/bezier.js"],"sourcesContent":["/**\r\n  A javascript Bezier curve library\r\n**/\r\n\r\n// math-inlining.\r\nconst { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\r\n\r\n// cube root function yielding real roots\r\nfunction crt(v) {\r\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\r\n}\r\n\r\n// trig constants\r\nconst pi = Math.PI,\r\n  tau = 2 * pi,\r\n  quart = pi / 2,\r\n  // float precision significant decimal\r\n  epsilon = 0.000001,\r\n  // extremas used in bbox calculation and similar algorithms\r\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\r\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\r\n  // a zero coordinate, which is surprisingly useful\r\n  ZERO = { x: 0, y: 0, z: 0 };\r\n\r\n// Bezier utility functions\r\nconst utils = {\r\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\r\n  Tvalues: [\r\n    -0.0640568928626056260850430826247450385909,\r\n    0.0640568928626056260850430826247450385909,\r\n    -0.1911188674736163091586398207570696318404,\r\n    0.1911188674736163091586398207570696318404,\r\n    -0.3150426796961633743867932913198102407864,\r\n    0.3150426796961633743867932913198102407864,\r\n    -0.4337935076260451384870842319133497124524,\r\n    0.4337935076260451384870842319133497124524,\r\n    -0.5454214713888395356583756172183723700107,\r\n    0.5454214713888395356583756172183723700107,\r\n    -0.6480936519369755692524957869107476266696,\r\n    0.6480936519369755692524957869107476266696,\r\n    -0.7401241915785543642438281030999784255232,\r\n    0.7401241915785543642438281030999784255232,\r\n    -0.8200019859739029219539498726697452080761,\r\n    0.8200019859739029219539498726697452080761,\r\n    -0.8864155270044010342131543419821967550873,\r\n    0.8864155270044010342131543419821967550873,\r\n    -0.9382745520027327585236490017087214496548,\r\n    0.9382745520027327585236490017087214496548,\r\n    -0.9747285559713094981983919930081690617411,\r\n    0.9747285559713094981983919930081690617411,\r\n    -0.9951872199970213601799974097007368118745,\r\n    0.9951872199970213601799974097007368118745,\r\n  ],\r\n\r\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\r\n  Cvalues: [\r\n    0.1279381953467521569740561652246953718517,\r\n    0.1279381953467521569740561652246953718517,\r\n    0.1258374563468282961213753825111836887264,\r\n    0.1258374563468282961213753825111836887264,\r\n    0.121670472927803391204463153476262425607,\r\n    0.121670472927803391204463153476262425607,\r\n    0.1155056680537256013533444839067835598622,\r\n    0.1155056680537256013533444839067835598622,\r\n    0.1074442701159656347825773424466062227946,\r\n    0.1074442701159656347825773424466062227946,\r\n    0.0976186521041138882698806644642471544279,\r\n    0.0976186521041138882698806644642471544279,\r\n    0.086190161531953275917185202983742667185,\r\n    0.086190161531953275917185202983742667185,\r\n    0.0733464814110803057340336152531165181193,\r\n    0.0733464814110803057340336152531165181193,\r\n    0.0592985849154367807463677585001085845412,\r\n    0.0592985849154367807463677585001085845412,\r\n    0.0442774388174198061686027482113382288593,\r\n    0.0442774388174198061686027482113382288593,\r\n    0.0285313886289336631813078159518782864491,\r\n    0.0285313886289336631813078159518782864491,\r\n    0.0123412297999871995468056670700372915759,\r\n    0.0123412297999871995468056670700372915759,\r\n  ],\r\n\r\n  arcfn: function (t, derivativeFn) {\r\n    const d = derivativeFn(t);\r\n    let l = d.x * d.x + d.y * d.y;\r\n    if (typeof d.z !== \"undefined\") {\r\n      l += d.z * d.z;\r\n    }\r\n    return sqrt(l);\r\n  },\r\n\r\n  compute: function (t, points, _3d) {\r\n    // shortcuts\r\n    if (t === 0) {\r\n      points[0].t = 0;\r\n      return points[0];\r\n    }\r\n\r\n    const order = points.length - 1;\r\n\r\n    if (t === 1) {\r\n      points[order].t = 1;\r\n      return points[order];\r\n    }\r\n\r\n    const mt = 1 - t;\r\n    let p = points;\r\n\r\n    // constant?\r\n    if (order === 0) {\r\n      points[0].t = t;\r\n      return points[0];\r\n    }\r\n\r\n    // linear?\r\n    if (order === 1) {\r\n      const ret = {\r\n        x: mt * p[0].x + t * p[1].x,\r\n        y: mt * p[0].y + t * p[1].y,\r\n        t: t,\r\n      };\r\n      if (_3d) {\r\n        ret.z = mt * p[0].z + t * p[1].z;\r\n      }\r\n      return ret;\r\n    }\r\n\r\n    // quadratic/cubic curve?\r\n    if (order < 4) {\r\n      let mt2 = mt * mt,\r\n        t2 = t * t,\r\n        a,\r\n        b,\r\n        c,\r\n        d = 0;\r\n      if (order === 2) {\r\n        p = [p[0], p[1], p[2], ZERO];\r\n        a = mt2;\r\n        b = mt * t * 2;\r\n        c = t2;\r\n      } else if (order === 3) {\r\n        a = mt2 * mt;\r\n        b = mt2 * t * 3;\r\n        c = mt * t2 * 3;\r\n        d = t * t2;\r\n      }\r\n      const ret = {\r\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\r\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\r\n        t: t,\r\n      };\r\n      if (_3d) {\r\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\r\n      }\r\n      return ret;\r\n    }\r\n\r\n    // higher order curves: use de Casteljau's computation\r\n    const dCpts = JSON.parse(JSON.stringify(points));\r\n    while (dCpts.length > 1) {\r\n      for (let i = 0; i < dCpts.length - 1; i++) {\r\n        dCpts[i] = {\r\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\r\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,\r\n        };\r\n        if (typeof dCpts[i].z !== \"undefined\") {\r\n          dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\r\n        }\r\n      }\r\n      dCpts.splice(dCpts.length - 1, 1);\r\n    }\r\n    dCpts[0].t = t;\r\n    return dCpts[0];\r\n  },\r\n\r\n  computeWithRatios: function (t, points, ratios, _3d) {\r\n    const mt = 1 - t,\r\n      r = ratios,\r\n      p = points;\r\n\r\n    let f1 = r[0],\r\n      f2 = r[1],\r\n      f3 = r[2],\r\n      f4 = r[3],\r\n      d;\r\n\r\n    // spec for linear\r\n    f1 *= mt;\r\n    f2 *= t;\r\n\r\n    if (p.length === 2) {\r\n      d = f1 + f2;\r\n      return {\r\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\r\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\r\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\r\n        t: t,\r\n      };\r\n    }\r\n\r\n    // upgrade to quadratic\r\n    f1 *= mt;\r\n    f2 *= 2 * mt;\r\n    f3 *= t * t;\r\n\r\n    if (p.length === 3) {\r\n      d = f1 + f2 + f3;\r\n      return {\r\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\r\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\r\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\r\n        t: t,\r\n      };\r\n    }\r\n\r\n    // upgrade to cubic\r\n    f1 *= mt;\r\n    f2 *= 1.5 * mt;\r\n    f3 *= 3 * mt;\r\n    f4 *= t * t * t;\r\n\r\n    if (p.length === 4) {\r\n      d = f1 + f2 + f3 + f4;\r\n      return {\r\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\r\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\r\n        z: !_3d\r\n          ? false\r\n          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\r\n        t: t,\r\n      };\r\n    }\r\n  },\r\n\r\n  derive: function (points, _3d) {\r\n    const dpoints = [];\r\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\r\n      const list = [];\r\n      for (let j = 0, dpt; j < c; j++) {\r\n        dpt = {\r\n          x: c * (p[j + 1].x - p[j].x),\r\n          y: c * (p[j + 1].y - p[j].y),\r\n        };\r\n        if (_3d) {\r\n          dpt.z = c * (p[j + 1].z - p[j].z);\r\n        }\r\n        list.push(dpt);\r\n      }\r\n      dpoints.push(list);\r\n      p = list;\r\n    }\r\n    return dpoints;\r\n  },\r\n\r\n  between: function (v, m, M) {\r\n    return (\r\n      (m <= v && v <= M) ||\r\n      utils.approximately(v, m) ||\r\n      utils.approximately(v, M)\r\n    );\r\n  },\r\n\r\n  approximately: function (a, b, precision) {\r\n    return abs(a - b) <= (precision || epsilon);\r\n  },\r\n\r\n  length: function (derivativeFn) {\r\n    const z = 0.5,\r\n      len = utils.Tvalues.length;\r\n\r\n    let sum = 0;\r\n\r\n    for (let i = 0, t; i < len; i++) {\r\n      t = z * utils.Tvalues[i] + z;\r\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\r\n    }\r\n    return z * sum;\r\n  },\r\n\r\n  map: function (v, ds, de, ts, te) {\r\n    const d1 = de - ds,\r\n      d2 = te - ts,\r\n      v2 = v - ds,\r\n      r = v2 / d1;\r\n    return ts + d2 * r;\r\n  },\r\n\r\n  lerp: function (r, v1, v2) {\r\n    const ret = {\r\n      x: v1.x + r * (v2.x - v1.x),\r\n      y: v1.y + r * (v2.y - v1.y),\r\n    };\r\n    if (v1.z !== undefined && v2.z !== undefined) {\r\n      ret.z = v1.z + r * (v2.z - v1.z);\r\n    }\r\n    return ret;\r\n  },\r\n\r\n  pointToString: function (p) {\r\n    let s = p.x + \"/\" + p.y;\r\n    if (typeof p.z !== \"undefined\") {\r\n      s += \"/\" + p.z;\r\n    }\r\n    return s;\r\n  },\r\n\r\n  pointsToString: function (points) {\r\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\r\n  },\r\n\r\n  copy: function (obj) {\r\n    return JSON.parse(JSON.stringify(obj));\r\n  },\r\n\r\n  angle: function (o, v1, v2) {\r\n    const dx1 = v1.x - o.x,\r\n      dy1 = v1.y - o.y,\r\n      dx2 = v2.x - o.x,\r\n      dy2 = v2.y - o.y,\r\n      cross = dx1 * dy2 - dy1 * dx2,\r\n      dot = dx1 * dx2 + dy1 * dy2;\r\n    return atan2(cross, dot);\r\n  },\r\n\r\n  // round as string, to avoid rounding errors\r\n  round: function (v, d) {\r\n    const s = \"\" + v;\r\n    const pos = s.indexOf(\".\");\r\n    return parseFloat(s.substring(0, pos + 1 + d));\r\n  },\r\n\r\n  dist: function (p1, p2) {\r\n    const dx = p1.x - p2.x,\r\n      dy = p1.y - p2.y;\r\n    return sqrt(dx * dx + dy * dy);\r\n  },\r\n\r\n  closest: function (LUT, point) {\r\n    let mdist = pow(2, 63),\r\n      mpos,\r\n      d;\r\n    LUT.forEach(function (p, idx) {\r\n      d = utils.dist(point, p);\r\n      if (d < mdist) {\r\n        mdist = d;\r\n        mpos = idx;\r\n      }\r\n    });\r\n    return { mdist: mdist, mpos: mpos };\r\n  },\r\n\r\n  abcratio: function (t, n) {\r\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\r\n    if (n !== 2 && n !== 3) {\r\n      return false;\r\n    }\r\n    if (typeof t === \"undefined\") {\r\n      t = 0.5;\r\n    } else if (t === 0 || t === 1) {\r\n      return t;\r\n    }\r\n    const bottom = pow(t, n) + pow(1 - t, n),\r\n      top = bottom - 1;\r\n    return abs(top / bottom);\r\n  },\r\n\r\n  projectionratio: function (t, n) {\r\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\r\n    if (n !== 2 && n !== 3) {\r\n      return false;\r\n    }\r\n    if (typeof t === \"undefined\") {\r\n      t = 0.5;\r\n    } else if (t === 0 || t === 1) {\r\n      return t;\r\n    }\r\n    const top = pow(1 - t, n),\r\n      bottom = pow(t, n) + top;\r\n    return top / bottom;\r\n  },\r\n\r\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\r\n    const nx =\r\n      (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\r\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\r\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\r\n    if (d == 0) {\r\n      return false;\r\n    }\r\n    return { x: nx / d, y: ny / d };\r\n  },\r\n\r\n  lli4: function (p1, p2, p3, p4) {\r\n    const x1 = p1.x,\r\n      y1 = p1.y,\r\n      x2 = p2.x,\r\n      y2 = p2.y,\r\n      x3 = p3.x,\r\n      y3 = p3.y,\r\n      x4 = p4.x,\r\n      y4 = p4.y;\r\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\r\n  },\r\n\r\n  lli: function (v1, v2) {\r\n    return utils.lli4(v1, v1.c, v2, v2.c);\r\n  },\r\n\r\n  makeline: function (p1, p2) {\r\n    return new Bezier(\r\n      p1.x,\r\n      p1.y,\r\n      (p1.x + p2.x) / 2,\r\n      (p1.y + p2.y) / 2,\r\n      p2.x,\r\n      p2.y\r\n    );\r\n  },\r\n\r\n  findbbox: function (sections) {\r\n    let mx = nMax,\r\n      my = nMax,\r\n      MX = nMin,\r\n      MY = nMin;\r\n    sections.forEach(function (s) {\r\n      const bbox = s.bbox();\r\n      if (mx > bbox.x.min) mx = bbox.x.min;\r\n      if (my > bbox.y.min) my = bbox.y.min;\r\n      if (MX < bbox.x.max) MX = bbox.x.max;\r\n      if (MY < bbox.y.max) MY = bbox.y.max;\r\n    });\r\n    return {\r\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\r\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },\r\n    };\r\n  },\r\n\r\n  shapeintersections: function (\r\n    s1,\r\n    bbox1,\r\n    s2,\r\n    bbox2,\r\n    curveIntersectionThreshold\r\n  ) {\r\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\r\n    const intersections = [];\r\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\r\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\r\n    a1.forEach(function (l1) {\r\n      if (l1.virtual) return;\r\n      a2.forEach(function (l2) {\r\n        if (l2.virtual) return;\r\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\r\n        if (iss.length > 0) {\r\n          iss.c1 = l1;\r\n          iss.c2 = l2;\r\n          iss.s1 = s1;\r\n          iss.s2 = s2;\r\n          intersections.push(iss);\r\n        }\r\n      });\r\n    });\r\n    return intersections;\r\n  },\r\n\r\n  makeshape: function (forward, back, curveIntersectionThreshold) {\r\n    const bpl = back.points.length;\r\n    const fpl = forward.points.length;\r\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\r\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\r\n    const shape = {\r\n      startcap: start,\r\n      forward: forward,\r\n      back: back,\r\n      endcap: end,\r\n      bbox: utils.findbbox([start, forward, back, end]),\r\n    };\r\n    shape.intersections = function (s2) {\r\n      return utils.shapeintersections(\r\n        shape,\r\n        shape.bbox,\r\n        s2,\r\n        s2.bbox,\r\n        curveIntersectionThreshold\r\n      );\r\n    };\r\n    return shape;\r\n  },\r\n\r\n  getminmax: function (curve, d, list) {\r\n    if (!list) return { min: 0, max: 0 };\r\n    let min = nMax,\r\n      max = nMin,\r\n      t,\r\n      c;\r\n    if (list.indexOf(0) === -1) {\r\n      list = [0].concat(list);\r\n    }\r\n    if (list.indexOf(1) === -1) {\r\n      list.push(1);\r\n    }\r\n    for (let i = 0, len = list.length; i < len; i++) {\r\n      t = list[i];\r\n      c = curve.get(t);\r\n      if (c[d] < min) {\r\n        min = c[d];\r\n      }\r\n      if (c[d] > max) {\r\n        max = c[d];\r\n      }\r\n    }\r\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\r\n  },\r\n\r\n  translate: function (points) {\r\n    // translate to (0,0)\r\n    let m = points[0];\r\n    return points.map(v => {\r\n      return {\r\n        x: v.x - m.x,\r\n        y: v.y - m.y\r\n      }\r\n    });\r\n  },\r\n\r\n  rotate: function (points) {\r\n    // rotate so that last point is (_,0)\r\n    const last = points.length - 1,\r\n      dx = points[last].x,\r\n      dy = points[last].y,\r\n      a = atan2(dy, dx);\r\n    return points.map(v => {\r\n      return {\r\n        a: a,\r\n        x: v.x * cos(-a) - v.y * sin(-a),\r\n        y: v.x * sin(-a) + v.y * cos(-a)\r\n      }\r\n    })\r\n  },\r\n\r\n  align: function (points, line) {\r\n    const tx = line.p1.x,\r\n      ty = line.p1.y,\r\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\r\n      d = function (v) {\r\n        return {\r\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\r\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),\r\n        };\r\n      };\r\n    return points.map(d);\r\n  },\r\n\r\n  roots: function (points, line) {\r\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\r\n\r\n    const order = points.length - 1;\r\n    const aligned = utils.align(points, line);\r\n    const reduce = function (t) {\r\n      return 0 <= t && t <= 1;\r\n    };\r\n\r\n    if (order === 2) {\r\n      const a = aligned[0].y,\r\n        b = aligned[1].y,\r\n        c = aligned[2].y,\r\n        d = a - 2 * b + c;\r\n      if (d !== 0) {\r\n        const m1 = -sqrt(b * b - a * c),\r\n          m2 = -a + b,\r\n          v1 = -(m1 + m2) / d,\r\n          v2 = -(-m1 + m2) / d;\r\n        return [v1, v2].filter(reduce);\r\n      } else if (b !== c && d === 0) {\r\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\r\n      }\r\n      return [];\r\n    }\r\n\r\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\r\n    const pa = aligned[0].y,\r\n      pb = aligned[1].y,\r\n      pc = aligned[2].y,\r\n      pd = aligned[3].y;\r\n\r\n    let d = -pa + 3 * pb - 3 * pc + pd,\r\n      a = 3 * pa - 6 * pb + 3 * pc,\r\n      b = -3 * pa + 3 * pb,\r\n      c = pa;\r\n\r\n    if (utils.approximately(d, 0)) {\r\n      // this is not a cubic curve.\r\n      if (utils.approximately(a, 0)) {\r\n        // in fact, this is not a quadratic curve either.\r\n        if (utils.approximately(b, 0)) {\r\n          // in fact in fact, there are no solutions.\r\n          return [];\r\n        }\r\n        // linear solution:\r\n        return [-c / b].filter(reduce);\r\n      }\r\n      // quadratic solution:\r\n      const q = sqrt(b * b - 4 * a * c),\r\n        a2 = 2 * a;\r\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\r\n    }\r\n\r\n    // at this point, we know we need a cubic solution:\r\n\r\n    a /= d;\r\n    b /= d;\r\n    c /= d;\r\n\r\n    const p = (3 * b - a * a) / 3,\r\n      p3 = p / 3,\r\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\r\n      q2 = q / 2,\r\n      discriminant = q2 * q2 + p3 * p3 * p3;\r\n\r\n    let u1, v1, x1, x2, x3;\r\n    if (discriminant < 0) {\r\n      const mp3 = -p / 3,\r\n        mp33 = mp3 * mp3 * mp3,\r\n        r = sqrt(mp33),\r\n        t = -q / (2 * r),\r\n        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\r\n        phi = acos(cosphi),\r\n        crtr = crt(r),\r\n        t1 = 2 * crtr;\r\n      x1 = t1 * cos(phi / 3) - a / 3;\r\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\r\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\r\n      return [x1, x2, x3].filter(reduce);\r\n    } else if (discriminant === 0) {\r\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\r\n      x1 = 2 * u1 - a / 3;\r\n      x2 = -u1 - a / 3;\r\n      return [x1, x2].filter(reduce);\r\n    } else {\r\n      const sd = sqrt(discriminant);\r\n      u1 = crt(-q2 + sd);\r\n      v1 = crt(q2 + sd);\r\n      return [u1 - v1 - a / 3].filter(reduce);\r\n    }\r\n  },\r\n\r\n  droots: function (p) {\r\n    // quadratic roots are easy\r\n    if (p.length === 3) {\r\n      const a = p[0],\r\n        b = p[1],\r\n        c = p[2],\r\n        d = a - 2 * b + c;\r\n      if (d !== 0) {\r\n        const m1 = -sqrt(b * b - a * c),\r\n          m2 = -a + b,\r\n          v1 = -(m1 + m2) / d,\r\n          v2 = -(-m1 + m2) / d;\r\n        return [v1, v2];\r\n      } else if (b !== c && d === 0) {\r\n        return [(2 * b - c) / (2 * (b - c))];\r\n      }\r\n      return [];\r\n    }\r\n\r\n    // linear roots are even easier\r\n    if (p.length === 2) {\r\n      const a = p[0],\r\n        b = p[1];\r\n      if (a !== b) {\r\n        return [a / (a - b)];\r\n      }\r\n      return [];\r\n    }\r\n\r\n    return [];\r\n  },\r\n\r\n  curvature: function (t, d1, d2, _3d, kOnly) {\r\n    let num,\r\n      dnm,\r\n      adk,\r\n      dk,\r\n      k = 0,\r\n      r = 0;\r\n\r\n    //\r\n    // We're using the following formula for curvature:\r\n    //\r\n    //              x'y\" - y'x\"\r\n    //   k(t) = ------------------\r\n    //           (x'² + y'²)^(3/2)\r\n    //\r\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\r\n    //\r\n    // With it corresponding 3D counterpart:\r\n    //\r\n    //          sqrt( (y'z\" - y\"z')² + (z'x\" - z\"x')² + (x'y\" - x\"y')²)\r\n    //   k(t) = -------------------------------------------------------\r\n    //                     (x'² + y'² + z'²)^(3/2)\r\n    //\r\n\r\n    const d = utils.compute(t, d1);\r\n    const dd = utils.compute(t, d2);\r\n    const qdsum = d.x * d.x + d.y * d.y;\r\n\r\n    if (_3d) {\r\n      num = sqrt(\r\n        pow(d.y * dd.z - dd.y * d.z, 2) +\r\n        pow(d.z * dd.x - dd.z * d.x, 2) +\r\n        pow(d.x * dd.y - dd.x * d.y, 2)\r\n      );\r\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\r\n    } else {\r\n      num = d.x * dd.y - d.y * dd.x;\r\n      dnm = pow(qdsum, 3 / 2);\r\n    }\r\n\r\n    if (num === 0 || dnm === 0) {\r\n      return { k: 0, r: 0 };\r\n    }\r\n\r\n    k = num / dnm;\r\n    r = dnm / num;\r\n\r\n    // We're also computing the derivative of kappa, because\r\n    // there is value in knowing the rate of change for the\r\n    // curvature along the curve. And we're just going to\r\n    // ballpark it based on an epsilon.\r\n    if (!kOnly) {\r\n      // compute k'(t) based on the interval before, and after it,\r\n      // to at least try to not introduce forward/backward pass bias.\r\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\r\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\r\n      dk = (nk - k + (k - pk)) / 2;\r\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\r\n    }\r\n\r\n    return { k: k, r: r, dk: dk, adk: adk };\r\n  },\r\n\r\n  inflections: function (points) {\r\n    if (points.length < 4) return [];\r\n\r\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\r\n\r\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),\r\n      a = p[2].x * p[1].y,\r\n      b = p[3].x * p[1].y,\r\n      c = p[1].x * p[2].y,\r\n      d = p[3].x * p[2].y,\r\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\r\n      v2 = 18 * (3 * a - b - 3 * c),\r\n      v3 = 18 * (c - a);\r\n\r\n    if (utils.approximately(v1, 0)) {\r\n      if (!utils.approximately(v2, 0)) {\r\n        let t = -v3 / v2;\r\n        if (0 <= t && t <= 1) return [t];\r\n      }\r\n      return [];\r\n    }\r\n\r\n    const trm = v2 * v2 - 4 * v1 * v3,\r\n      sq = Math.sqrt(trm),\r\n      d2 = 2 * v1;\r\n\r\n    if (utils.approximately(d2, 0)) return [];\r\n\r\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\r\n      return 0 <= r && r <= 1;\r\n    });\r\n  },\r\n\r\n  bboxoverlap: function (b1, b2) {\r\n    const dims = [\"x\", \"y\"],\r\n      len = dims.length;\r\n\r\n    for (let i = 0, dim, l, t, d; i < len; i++) {\r\n      dim = dims[i];\r\n      l = b1[dim].mid;\r\n      t = b2[dim].mid;\r\n      d = (b1[dim].size + b2[dim].size) / 2;\r\n      if (abs(l - t) >= d) return false;\r\n    }\r\n    return true;\r\n  },\r\n\r\n  expandbox: function (bbox, _bbox) {\r\n    if (_bbox.x.min < bbox.x.min) {\r\n      bbox.x.min = _bbox.x.min;\r\n    }\r\n    if (_bbox.y.min < bbox.y.min) {\r\n      bbox.y.min = _bbox.y.min;\r\n    }\r\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\r\n      bbox.z.min = _bbox.z.min;\r\n    }\r\n    if (_bbox.x.max > bbox.x.max) {\r\n      bbox.x.max = _bbox.x.max;\r\n    }\r\n    if (_bbox.y.max > bbox.y.max) {\r\n      bbox.y.max = _bbox.y.max;\r\n    }\r\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\r\n      bbox.z.max = _bbox.z.max;\r\n    }\r\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\r\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\r\n    if (bbox.z) {\r\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\r\n    }\r\n    bbox.x.size = bbox.x.max - bbox.x.min;\r\n    bbox.y.size = bbox.y.max - bbox.y.min;\r\n    if (bbox.z) {\r\n      bbox.z.size = bbox.z.max - bbox.z.min;\r\n    }\r\n  },\r\n\r\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\r\n    const c1b = c1.bbox(),\r\n      c2b = c2.bbox(),\r\n      r = 100000,\r\n      threshold = curveIntersectionThreshold || 0.5;\r\n\r\n    if (\r\n      c1b.x.size + c1b.y.size < threshold &&\r\n      c2b.x.size + c2b.y.size < threshold\r\n    ) {\r\n      return [\r\n        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +\r\n        \"/\" +\r\n        (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,\r\n      ];\r\n    }\r\n\r\n    let cc1 = c1.split(0.5),\r\n      cc2 = c2.split(0.5),\r\n      pairs = [\r\n        { left: cc1.left, right: cc2.left },\r\n        { left: cc1.left, right: cc2.right },\r\n        { left: cc1.right, right: cc2.right },\r\n        { left: cc1.right, right: cc2.left },\r\n      ];\r\n\r\n    pairs = pairs.filter(function (pair) {\r\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\r\n    });\r\n\r\n    let results = [];\r\n\r\n    if (pairs.length === 0) return results;\r\n\r\n    pairs.forEach(function (pair) {\r\n      results = results.concat(\r\n        utils.pairiteration(pair.left, pair.right, threshold)\r\n      );\r\n    });\r\n\r\n    results = results.filter(function (v, i) {\r\n      return results.indexOf(v) === i;\r\n    });\r\n\r\n    return results;\r\n  },\r\n\r\n  getccenter: function (p1, p2, p3) {\r\n    const dx1 = p2.x - p1.x,\r\n      dy1 = p2.y - p1.y,\r\n      dx2 = p3.x - p2.x,\r\n      dy2 = p3.y - p2.y,\r\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\r\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\r\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\r\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\r\n      // chord midpoints\r\n      mx1 = (p1.x + p2.x) / 2,\r\n      my1 = (p1.y + p2.y) / 2,\r\n      mx2 = (p2.x + p3.x) / 2,\r\n      my2 = (p2.y + p3.y) / 2,\r\n      // midpoint offsets\r\n      mx1n = mx1 + dx1p,\r\n      my1n = my1 + dy1p,\r\n      mx2n = mx2 + dx2p,\r\n      my2n = my2 + dy2p,\r\n      // intersection of these lines:\r\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\r\n      r = utils.dist(arc, p1);\r\n\r\n    // arc start/end values, over mid point:\r\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\r\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\r\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\r\n      _;\r\n\r\n    // determine arc direction (cw/ccw correction)\r\n    if (s < e) {\r\n      // if s<m<e, arc(s, e)\r\n      // if m<s<e, arc(e, s + tau)\r\n      // if s<e<m, arc(e, s + tau)\r\n      if (s > m || m > e) {\r\n        s += tau;\r\n      }\r\n      if (s > e) {\r\n        _ = e;\r\n        e = s;\r\n        s = _;\r\n      }\r\n    } else {\r\n      // if e<m<s, arc(e, s)\r\n      // if m<e<s, arc(s, e + tau)\r\n      // if e<s<m, arc(s, e + tau)\r\n      if (e < m && m < s) {\r\n        _ = e;\r\n        e = s;\r\n        s = _;\r\n      } else {\r\n        e += tau;\r\n      }\r\n    }\r\n    // assign and done.\r\n    arc.s = s;\r\n    arc.e = e;\r\n    arc.r = r;\r\n    return arc;\r\n  },\r\n\r\n  numberSort: function (a, b) {\r\n    return a - b;\r\n  },\r\n\r\n  midpoint: function (p1, p2) {\r\n    const mpx = (p1.x + p2.x) / 2, mpy = (p1.y + p2.y) / 2;\r\n    return { x: mpx, y: mpy };\r\n  },\r\n\r\n  checkcoincidation: function (p1, p2) {\r\n    if (p1.x == p2.x && p1.y == p2.y) { return true };\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Poly Bezier\r\n * @param {[type]} curves [description]\r\n */\r\nclass PolyBezier {\r\n  constructor(curves) {\r\n    this.curves = [];\r\n    this._3d = false;\r\n    if (!!curves) {\r\n      this.curves = curves;\r\n      this._3d = this.curves[0]._3d;\r\n    }\r\n    this._closed = utils.checkcoincidation(this.lastPathPoint(), this.firstPathPoint());\r\n    this.setJoinC_0();\r\n  }\r\n\r\n  curve(idx) {\r\n    return this.curves[idx];\r\n  }\r\n\r\n  firstPathCurve() {\r\n    return this.curves[0];\r\n  }\r\n\r\n  firstPathPoint() {\r\n    return this.firstPathCurve().points[0];\r\n  }\r\n\r\n  lastPathCurve() {\r\n    return this.curves[this.curves.length - 1];\r\n  }\r\n\r\n  lastPathPoint() {\r\n    return this.lastPathCurve().lastPoint();\r\n  }\r\n\r\n  setJoinC_0() {\r\n    // if the initial point of a curve is not equal to the last point of the next curve,\r\n    // it becomes the midpoint between them.\r\n    for (let i = 0; i < this.curves.length - 1; i++) {\r\n      const curve1 = this.curve(i), curve2 = this.curve(i + 1);\r\n      const lp = curve1.lastPoint(), fp = curve2.points[0];\r\n      if (!utils.checkcoincidation(lp, fp)) {\r\n        const midpoint = utils.midpoint(lp, fp);\r\n        curve1.points[curve1.lastPointIdx()] = midpoint;\r\n        curve2.points[0] = midpoint;\r\n      }\r\n    }\r\n  }\r\n\r\n  closePath() {\r\n    // the last point of the path becomes coincident with the first one, if they're not.\r\n    if (!this._closed) {\r\n      const lastCurve = this.lastPathCurve();\r\n      lastCurve.points[lastCurve.lastPointIdx()] = this.firstPathPoint();\r\n      this._closed = true;\r\n    } else return;\r\n  }\r\n\r\n  valueOf() {\r\n    return this.toString();\r\n  }\r\n\r\n  toString() {\r\n    return (\r\n      \"[\" +\r\n      this.curves\r\n        .map(function (curve) {\r\n          return utils.pointsToString(curve.points);\r\n        })\r\n        .join(\", \") +\r\n      \"]\"\r\n    );\r\n  }\r\n\r\n  addCurve(curve) {\r\n    this.curves.push(curve);\r\n    this._3d = this._3d || curve._3d;\r\n  }\r\n\r\n  length() {\r\n    return this.curves\r\n      .map(function (v) {\r\n        return v.length();\r\n      })\r\n      .reduce(function (a, b) {\r\n        return a + b;\r\n      });\r\n  }\r\n\r\n  bbox() {\r\n    const c = this.curves;\r\n    var bbox = c[0].bbox();\r\n    for (var i = 1; i < c.length; i++) {\r\n      utils.expandbox(bbox, c[i].bbox());\r\n    }\r\n    return bbox;\r\n  }\r\n\r\n  offset(d) {\r\n    const offset = [];\r\n    this.curves.forEach(function (v) {\r\n      offset.push(...v.offset(d));\r\n    });\r\n    return new PolyBezier(offset);\r\n  }\r\n}\r\n\r\n// math-inlining.\r\nconst { abs: abs$1, min, max, cos: cos$1, sin: sin$1, acos: acos$1, sqrt: sqrt$1 } = Math;\r\nconst pi$1 = Math.PI;\r\n\r\n/**\r\n * Bezier curve constructor.\r\n */\r\nclass Bezier {\r\n  constructor(coords) {\r\n    let args =\r\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\r\n    let coordlen = false;\r\n\r\n    if (typeof args[0] === \"object\") {\r\n      coordlen = args.length;\r\n      const newargs = [];\r\n      args.forEach(function (point) {\r\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\r\n          if (typeof point[d] !== \"undefined\") {\r\n            newargs.push(point[d]);\r\n          }\r\n        });\r\n      });\r\n      args = newargs;\r\n    }\r\n\r\n    let higher = false;\r\n    const len = args.length;\r\n\r\n    if (coordlen) {\r\n      if (coordlen > 4) {\r\n        if (arguments.length !== 1) {\r\n          throw new Error(\r\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\r\n          );\r\n        }\r\n        higher = true;\r\n      }\r\n    } else {\r\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\r\n        if (arguments.length !== 1) {\r\n          throw new Error(\r\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    const _3d = (this._3d =\r\n      (!higher && (len === 9 || len === 12)) ||\r\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\r\n\r\n    const points = (this.points = []);\r\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\r\n      var point = {\r\n        x: args[idx],\r\n        y: args[idx + 1],\r\n      };\r\n      if (_3d) {\r\n        point.z = args[idx + 2];\r\n      }\r\n      points.push(point);\r\n    }\r\n    const order = (this.order = points.length - 1);\r\n\r\n    const dims = (this.dims = [\"x\", \"y\"]);\r\n    if (_3d) dims.push(\"z\");\r\n    this.dimlen = dims.length;\r\n\r\n    // is this curve, practically speaking, a straight line?\r\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\r\n    const baselength = utils.dist(points[0], points[order]);\r\n    this._linear = aligned.reduce((t, p) => t + abs$1(p.y), 0) < baselength / 50;\r\n\r\n    this.curvepoints = [];\r\n    this._lut = [];\r\n    this.intersections = {};\r\n\r\n    this._t1 = 0;\r\n    this._t2 = 1;\r\n    this.update();\r\n  }\r\n\r\n  static quadraticFromPoints(p1, p2, p3, t) {\r\n    if (typeof t === \"undefined\") {\r\n      t = 0.5;\r\n    }\r\n    // shortcuts, although they're really dumb\r\n    if (t === 0) {\r\n      return new Bezier(p2, p2, p3);\r\n    }\r\n    if (t === 1) {\r\n      return new Bezier(p1, p2, p2);\r\n    }\r\n    // real fitting.\r\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\r\n    return new Bezier(p1, abc.A, p3);\r\n  }\r\n\r\n  static cubicFromPoints(S, B, E, t, d1) {\r\n    if (typeof t === \"undefined\") {\r\n      t = 0.5;\r\n    }\r\n    const abc = Bezier.getABC(3, S, B, E, t);\r\n    if (typeof d1 === \"undefined\") {\r\n      d1 = utils.dist(B, abc.C);\r\n    }\r\n    const d2 = (d1 * (1 - t)) / t;\r\n\r\n    const selen = utils.dist(S, E),\r\n      lx = (E.x - S.x) / selen,\r\n      ly = (E.y - S.y) / selen,\r\n      bx1 = d1 * lx,\r\n      by1 = d1 * ly,\r\n      bx2 = d2 * lx,\r\n      by2 = d2 * ly;\r\n    // derivation of new hull coordinates\r\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\r\n      e2 = { x: B.x + bx2, y: B.y + by2 },\r\n      A = abc.A,\r\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\r\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\r\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\r\n      nc2 = {\r\n        x: E.x + (v2.x - E.x) / (1 - t),\r\n        y: E.y + (v2.y - E.y) / (1 - t),\r\n      };\r\n    // ...done\r\n    return new Bezier(S, nc1, nc2, E);\r\n  }\r\n\r\n  static getUtils() {\r\n    return utils;\r\n  }\r\n\r\n  getUtils() {\r\n    return Bezier.getUtils();\r\n  }\r\n\r\n  lastPointIdx() {\r\n    return this.points.length - 1;\r\n  }\r\n\r\n  lastPoint() {\r\n    return this.points[this.lastPointIdx()];\r\n  }\r\n\r\n  static get PolyBezier() {\r\n    return PolyBezier;\r\n  }\r\n\r\n  valueOf() {\r\n    return this.toString();\r\n  }\r\n\r\n  toString() {\r\n    return utils.pointsToString(this.points);\r\n  }\r\n\r\n  toSVG() {\r\n    if (this._3d) return false;\r\n    const p = this.points,\r\n      x = p[0].x,\r\n      y = p[0].y,\r\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\r\n    for (let i = 1, last = p.length; i < last; i++) {\r\n      s.push(p[i].x);\r\n      s.push(p[i].y);\r\n    }\r\n    return s.join(\" \");\r\n  }\r\n\r\n  setRatios(ratios) {\r\n    if (ratios.length !== this.points.length) {\r\n      throw new Error(\"incorrect number of ratio values\");\r\n    }\r\n    this.ratios = ratios;\r\n    this._lut = []; //  invalidate any precomputed LUT\r\n  }\r\n\r\n  verify() {\r\n    const print = this.coordDigest();\r\n    if (print !== this._print) {\r\n      this._print = print;\r\n      this.update();\r\n    }\r\n  }\r\n\r\n  coordDigest() {\r\n    return this.points\r\n      .map(function (c, pos) {\r\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\r\n      })\r\n      .join(\"\");\r\n  }\r\n\r\n  update() {\r\n    // invalidate any precomputed LUT\r\n    this._lut = [];\r\n    this.dpoints = utils.derive(this.points, this._3d);\r\n    this.computedirection();\r\n    const cpts = this.curvepoints.length;\r\n    this.computeCurvePoints(cpts);\r\n  }\r\n\r\n  computeCurvePoints(steps = 1000) {\r\n    // the calculated curve points are stored in the this.curvepoints attribute\r\n    this.curvepoints = [];\r\n    for (let i = 0, p, t; i < steps; i++) {\r\n      t = i / (steps - 1);\r\n      p = this.compute(t);\r\n      p.t = t;\r\n      this.curvepoints.push(p);\r\n    }\r\n    return this.curvepoints;\r\n  }\r\n\r\n  computedirection() {\r\n    const points = this.points;\r\n    const angle = utils.angle(points[0], points[this.order], points[1]);\r\n    this.clockwise = angle > 0;\r\n  }\r\n\r\n  length() {\r\n    return this.len = utils.length(this.derivative.bind(this));\r\n  }\r\n\r\n  static getABC(order = 2, S, B, E, t = 0.5) {\r\n    const u = utils.projectionratio(t, order),\r\n      um = 1 - u,\r\n      C = {\r\n        x: u * S.x + um * E.x,\r\n        y: u * S.y + um * E.y,\r\n      },\r\n      s = utils.abcratio(t, order),\r\n      A = {\r\n        x: B.x + (B.x - C.x) / s,\r\n        y: B.y + (B.y - C.y) / s,\r\n      };\r\n    return { A, B, C, S, E };\r\n  }\r\n\r\n  getABC(t, B) {\r\n    B = B || this.get(t);\r\n    let S = this.points[0];\r\n    let E = this.points[this.order];\r\n    return Bezier.getABC(this.order, S, B, E, t);\r\n  }\r\n\r\n  getLUT(steps) {\r\n    this.verify();\r\n    steps = steps || 100;\r\n    if (this._lut.length === steps) {\r\n      return this._lut;\r\n    }\r\n    this._lut = [];\r\n    // n steps means n+1 points\r\n    steps++;\r\n    this._lut = [];\r\n    for (let i = 0, p, t; i < steps; i++) {\r\n      t = i / (steps - 1);\r\n      p = this.compute(t);\r\n      p.t = t;\r\n      this._lut.push(p);\r\n    }\r\n    return this._lut;\r\n  }\r\n\r\n  on(point, error) {\r\n    error = error || 5;\r\n    const lut = this.getLUT(),\r\n      hits = [];\r\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\r\n      c = lut[i];\r\n      if (utils.dist(c, point) < error) {\r\n        hits.push(c);\r\n        t += i / lut.length;\r\n      }\r\n    }\r\n    if (!hits.length) return false;\r\n    return (t /= hits.length);\r\n  }\r\n\r\n  project(point) {\r\n    // step 1: coarse check\r\n    const LUT = this.getLUT(),\r\n      l = LUT.length - 1,\r\n      closest = utils.closest(LUT, point),\r\n      mpos = closest.mpos,\r\n      t1 = (mpos - 1) / l,\r\n      t2 = (mpos + 1) / l,\r\n      step = 0.1 / l;\r\n\r\n    // step 2: fine check\r\n    let mdist = closest.mdist,\r\n      t = t1,\r\n      ft = t,\r\n      p;\r\n    mdist += 1;\r\n    for (let d; t < t2 + step; t += step) {\r\n      p = this.compute(t);\r\n      d = utils.dist(point, p);\r\n      if (d < mdist) {\r\n        mdist = d;\r\n        ft = t;\r\n      }\r\n    }\r\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\r\n    p = this.compute(ft);\r\n    p.t = ft;\r\n    p.d = mdist;\r\n    this.projp = { ...p, point: point };\r\n    return p;\r\n  }\r\n\r\n  get(t) {\r\n    return this.p = this.compute(t);\r\n  }\r\n\r\n  point(idx) {\r\n    return this.points[idx];\r\n  }\r\n\r\n  compute(t) {\r\n    if (this.ratios) {\r\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\r\n    }\r\n    return utils.compute(t, this.points, this._3d, this.ratios);\r\n  }\r\n\r\n  raise() {\r\n    const p = this.points,\r\n      np = [p[0]],\r\n      k = p.length;\r\n    for (let i = 1, pi, pim; i < k; i++) {\r\n      pi = p[i];\r\n      pim = p[i - 1];\r\n      np[i] = {\r\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\r\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\r\n      };\r\n    }\r\n    np[k] = p[k - 1];\r\n    return new Bezier(np);\r\n  }\r\n\r\n  derivative(t) {\r\n    const dv = utils.compute(t, this.dpoints[0], this._3d);\r\n    return this.dv = dv;\r\n  }\r\n\r\n  dderivative(t) {\r\n    return utils.compute(t, this.dpoints[1], this._3d);\r\n  }\r\n\r\n  align() {\r\n    let p = this.points;\r\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\r\n  }\r\n\r\n  curvature(t) {\r\n    const kr = utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\r\n    this.kr = { ...kr, t: t };\r\n    return kr;\r\n  }\r\n\r\n  inflections() {\r\n    return this.infl = utils.inflections(this.points);\r\n  }\r\n\r\n  normal(t) {\r\n    const n = this._3d ? this.__normal3(t) : this.__normal2(t);\r\n    this.norm = { ...n, t: t };\r\n    return n;\r\n  }\r\n\r\n  __normal2(t) {\r\n    const d = this.derivative(t);\r\n    const q = sqrt$1(d.x * d.x + d.y * d.y);\r\n    return { x: -d.y / q, y: d.x / q };\r\n  }\r\n\r\n  __normal3(t) {\r\n    // see http://stackoverflow.com/questions/25453159\r\n    const r1 = this.derivative(t),\r\n      r2 = this.derivative(t + 0.01),\r\n      q1 = sqrt$1(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\r\n      q2 = sqrt$1(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\r\n    r1.x /= q1;\r\n    r1.y /= q1;\r\n    r1.z /= q1;\r\n    r2.x /= q2;\r\n    r2.y /= q2;\r\n    r2.z /= q2;\r\n    // cross product\r\n    const c = {\r\n      x: r2.y * r1.z - r2.z * r1.y,\r\n      y: r2.z * r1.x - r2.x * r1.z,\r\n      z: r2.x * r1.y - r2.y * r1.x,\r\n    };\r\n    const m = sqrt$1(c.x * c.x + c.y * c.y + c.z * c.z);\r\n    c.x /= m;\r\n    c.y /= m;\r\n    c.z /= m;\r\n    // rotation matrix\r\n    const R = [\r\n      c.x * c.x,\r\n      c.x * c.y - c.z,\r\n      c.x * c.z + c.y,\r\n      c.x * c.y + c.z,\r\n      c.y * c.y,\r\n      c.y * c.z - c.x,\r\n      c.x * c.z - c.y,\r\n      c.y * c.z + c.x,\r\n      c.z * c.z,\r\n    ];\r\n    // normal vector:\r\n    const n = {\r\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\r\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\r\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\r\n    };\r\n    return n;\r\n  }\r\n\r\n  hull(t) {\r\n    let p = this.points,\r\n      _p = [],\r\n      q = [],\r\n      idx = 0;\r\n    q[idx++] = p[0];\r\n    q[idx++] = p[1];\r\n    q[idx++] = p[2];\r\n    if (this.order === 3) {\r\n      q[idx++] = p[3];\r\n    }\r\n    // we lerp between all points at each iteration, until we have 1 point left.\r\n    while (p.length > 1) {\r\n      _p = [];\r\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\r\n        pt = utils.lerp(t, p[i], p[i + 1]);\r\n        q[idx++] = pt;\r\n        _p.push(pt);\r\n      }\r\n      p = _p;\r\n    }\r\n    this.hullp = { ...q, t: t };\r\n    return q;\r\n  }\r\n\r\n  split(t1, t2) {\r\n    // shortcuts\r\n    if (t1 === 0 && !!t2) {\r\n      return this.subc = this.split(t2).left;\r\n    }\r\n    if (t2 === 1) {\r\n      return this.subc = this.split(t1).right;\r\n    }\r\n\r\n    // no shortcut: use \"de Casteljau\" iteration.\r\n    const q = this.hull(t1);\r\n    const result = {\r\n      left:\r\n        this.order === 2\r\n          ? new Bezier([q[0], q[3], q[5]])\r\n          : new Bezier([q[0], q[4], q[7], q[9]]),\r\n      right:\r\n        this.order === 2\r\n          ? new Bezier([q[5], q[4], q[2]])\r\n          : new Bezier([q[9], q[8], q[6], q[3]]),\r\n      span: q,\r\n    };\r\n\r\n    // make sure we bind _t1/_t2 information!\r\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\r\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\r\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\r\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\r\n\r\n    // if we have no t2, we're done\r\n    if (!t2) {\r\n      this.subc = { c: [result.left, result.right], t: t1 };\r\n      return result;\r\n    }\r\n\r\n    // if we have a t2, split again:\r\n    t2 = utils.map(t2, t1, 1, 0, 1);\r\n    const split = result.right.split(t2).left;\r\n    this.subc = { ...split, t1: t1, t2: t2 };\r\n    return split;\r\n  }\r\n\r\n  extrema() {\r\n    const result = {};\r\n    let roots = [];\r\n\r\n    this.dims.forEach(\r\n      function (dim) {\r\n        let mfn = function (v) {\r\n          return v[dim];\r\n        };\r\n        let p = this.dpoints[0].map(mfn);\r\n        result[dim] = utils.droots(p);\r\n        if (this.order === 3) {\r\n          p = this.dpoints[1].map(mfn);\r\n          result[dim] = result[dim].concat(utils.droots(p));\r\n        }\r\n        result[dim] = result[dim].filter(function (t) {\r\n          return t >= 0 && t <= 1;\r\n        });\r\n        roots = roots.concat(result[dim].sort(utils.numberSort));\r\n      }.bind(this)\r\n    );\r\n\r\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\r\n      return roots.indexOf(v) === idx;\r\n    });\r\n\r\n    return this.extrs = result;\r\n  }\r\n\r\n  bbox() {\r\n    const extrema = this.extrema(),\r\n      result = {};\r\n    this.dims.forEach(\r\n      function (d) {\r\n        result[d] = utils.getminmax(this, d, extrema[d]);\r\n      }.bind(this)\r\n    );\r\n    return this.bb = result;\r\n  }\r\n\r\n  tightbbox() {\r\n    const translated = utils.translate(this.points),\r\n      rotated = utils.rotate(translated),\r\n      rtcurve = this.align(this.points),\r\n      result = {};\r\n    rtcurve.bbox();\r\n    const minx = rtcurve.bb.x.min,\r\n      maxx = rtcurve.bb.x.max,\r\n      miny = rtcurve.bb.y.min,\r\n      maxy = rtcurve.bb.y.max,\r\n      t = this.points[0],\r\n      a = rotated[0].a;\r\n    result.p1 = { x: t.x + minx * cos(a) - miny * sin(a), y: t.y + minx * sin(a) + miny * cos(a) };\r\n    result.p2 = { x: t.x + maxx * cos(a) - miny * sin(a), y: t.y + maxx * sin(a) + miny * cos(a) };\r\n    result.p3 = { x: t.x + maxx * cos(a) - maxy * sin(a), y: t.y + maxx * sin(a) + maxy * cos(a) };\r\n    result.p4 = { x: t.x + minx * cos(a) - maxy * sin(a), y: t.y + minx * sin(a) + maxy * cos(a) };\r\n    return this.tbb = result;\r\n  }\r\n\r\n  overlaps(curve) {\r\n    const lbbox = this.bbox(),\r\n      tbbox = curve.bbox();\r\n    return utils.bboxoverlap(lbbox, tbbox);\r\n  }\r\n\r\n  offset(t, d) {\r\n    if (typeof d !== \"undefined\") {\r\n      const c = this.get(t),\r\n        n = this.normal(t);\r\n      const ret = {\r\n        c: c,\r\n        n: n,\r\n        x: c.x + n.x * d,\r\n        y: c.y + n.y * d,\r\n      };\r\n      if (this._3d) {\r\n        ret.z = c.z + n.z * d;\r\n      }\r\n      return this.offstcoords = ret;\r\n    }\r\n    if (this._linear) {\r\n      const nv = this.normal(0),\r\n        coords = this.points.map(function (p) {\r\n          const ret = {\r\n            x: p.x + t * nv.x,\r\n            y: p.y + t * nv.y,\r\n          };\r\n          if (p.z && nv.z) {\r\n            ret.z = p.z + t * nv.z;\r\n          }\r\n          return ret;\r\n        });\r\n      return this.offst = [new Bezier(coords)];\r\n    }\r\n    return this.offst = this.reduce().map(function (s) {\r\n      if (s._linear) {\r\n        return s.offset(t)[0];\r\n      }\r\n      return s.scale(t);\r\n    });\r\n  }\r\n\r\n  simple() {\r\n    if (this.order === 3) {\r\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\r\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\r\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\r\n    }\r\n    const n1 = this.normal(0);\r\n    const n2 = this.normal(1);\r\n    let s = n1.x * n2.x + n1.y * n2.y;\r\n    if (this._3d) {\r\n      s += n1.z * n2.z;\r\n    }\r\n    return abs$1(acos$1(s)) < pi$1 / 3;\r\n  }\r\n\r\n  reduce() {\r\n    // TODO: examine these var types in more detail...\r\n    let i,\r\n      t1 = 0,\r\n      t2 = 0,\r\n      step = 0.01,\r\n      segment,\r\n      pass1 = [],\r\n      pass2 = [];\r\n    // first pass: split on extrema\r\n    let extrema = this.extrema().values;\r\n    if (extrema.indexOf(0) === -1) {\r\n      extrema = [0].concat(extrema);\r\n    }\r\n    if (extrema.indexOf(1) === -1) {\r\n      extrema.push(1);\r\n    }\r\n\r\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\r\n      t2 = extrema[i];\r\n      segment = this.split(t1, t2);\r\n      segment._t1 = t1;\r\n      segment._t2 = t2;\r\n      pass1.push(segment);\r\n      t1 = t2;\r\n    }\r\n\r\n    // second pass: further reduce these segments to simple segments\r\n    pass1.forEach(function (p1) {\r\n      t1 = 0;\r\n      t2 = 0;\r\n      while (t2 <= 1) {\r\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\r\n          segment = p1.split(t1, t2);\r\n          if (!segment.simple()) {\r\n            t2 -= step;\r\n            if (abs$1(t1 - t2) < step) {\r\n              // we can never form a reduction\r\n              return [];\r\n            }\r\n            segment = p1.split(t1, t2);\r\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\r\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\r\n            pass2.push(segment);\r\n            t1 = t2;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      if (t1 < 1) {\r\n        segment = p1.split(t1, 1);\r\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\r\n        segment._t2 = p1._t2;\r\n        pass2.push(segment);\r\n      }\r\n    });\r\n    return this.redc = pass2;\r\n  }\r\n\r\n  translate(v, d1, d2) {\r\n    d2 = typeof d2 === \"number\" ? d2 : d1;\r\n\r\n    // TODO: make this take curves with control points outside\r\n    //       of the start-end interval into account\r\n\r\n    const o = this.order;\r\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);\r\n    return new Bezier(\r\n      this.points.map((p, i) => ({\r\n        x: p.x + v.x * d[i],\r\n        y: p.y + v.y * d[i],\r\n      }))\r\n    );\r\n  }\r\n\r\n  scale(d) {\r\n    const order = this.order;\r\n    let distanceFn = false;\r\n    if (typeof d === \"function\") {\r\n      distanceFn = d;\r\n    }\r\n    if (distanceFn && order === 2) {\r\n      return this.scaled = this.raise().scale(distanceFn);\r\n    }\r\n\r\n    // TODO: add special handling for non-linear degenerate curves.\r\n\r\n    const clockwise = this.clockwise;\r\n    const points = this.points;\r\n\r\n    if (this._linear) {\r\n      return this.scaled = this.translate(\r\n        this.normal(0),\r\n        distanceFn ? distanceFn(0) : d,\r\n        distanceFn ? distanceFn(1) : d\r\n      );\r\n    }\r\n\r\n    const r1 = distanceFn ? distanceFn(0) : d;\r\n    const r2 = distanceFn ? distanceFn(1) : d;\r\n    const v = [this.offset(0, 10), this.offset(1, 10)];\r\n    const np = [];\r\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\r\n\r\n    if (!o) {\r\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\r\n    }\r\n\r\n    // move all points by distance 'd' wrt the origin 'o',\r\n    // and move end points by fixed distance along normal.\r\n    [0, 1].forEach(function (t) {\r\n      const p = (np[t * order] = utils.copy(points[t * order]));\r\n      p.x += (t ? r2 : r1) * v[t].n.x;\r\n      p.y += (t ? r2 : r1) * v[t].n.y;\r\n    });\r\n\r\n    if (!distanceFn) {\r\n      // move control points to lie on the intersection of the offset\r\n      // derivative vector, and the origin-through-control vector\r\n      [0, 1].forEach((t) => {\r\n        if (order === 2 && !!t) return;\r\n        const p = np[t * order];\r\n        const d = this.derivative(t);\r\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\r\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\r\n      });\r\n      return this.scaled = new Bezier(np);\r\n    }\r\n\r\n    // move control points by \"however much necessary to\r\n    // ensure the correct tangent to endpoint\".\r\n    [0, 1].forEach(function (t) {\r\n      if (order === 2 && !!t) return;\r\n      var p = points[t + 1];\r\n      var ov = {\r\n        x: p.x - o.x,\r\n        y: p.y - o.y,\r\n      };\r\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\r\n      if (distanceFn && !clockwise) rc = -rc;\r\n      var m = sqrt$1(ov.x * ov.x + ov.y * ov.y);\r\n      ov.x /= m;\r\n      ov.y /= m;\r\n      np[t + 1] = {\r\n        x: p.x + rc * ov.x,\r\n        y: p.y + rc * ov.y,\r\n      };\r\n    });\r\n    return this.scaled = new Bezier(np);\r\n  }\r\n\r\n  outline(d1, d2, d3, d4) {\r\n    d2 = d2 === undefined ? d1 : d2;\r\n\r\n    if (this._linear) {\r\n      // TODO: find the actual extrema, because they might\r\n      //       be before the start, or past the end.\r\n\r\n      const n = this.normal(0);\r\n      const start = this.points[0];\r\n      const end = this.points[this.points.length - 1];\r\n      let s, mid, e;\r\n\r\n      if (d3 === undefined) {\r\n        d3 = d1;\r\n        d4 = d2;\r\n      }\r\n\r\n      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };\r\n      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };\r\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\r\n      const fline = [s, mid, e];\r\n\r\n      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };\r\n      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };\r\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\r\n      const bline = [e, mid, s];\r\n\r\n      const ls = utils.makeline(bline[2], fline[0]);\r\n      const le = utils.makeline(fline[2], bline[0]);\r\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\r\n      return this.outl = new PolyBezier(segments);\r\n    }\r\n\r\n    const reduced = this.reduce(),\r\n      len = reduced.length,\r\n      fcurves = [];\r\n\r\n    let bcurves = [],\r\n      p,\r\n      alen = 0,\r\n      tlen = this.length();\r\n\r\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\r\n\r\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\r\n      return function (v) {\r\n        const f1 = alen / tlen,\r\n          f2 = (alen + slen) / tlen,\r\n          d = e - s;\r\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\r\n      };\r\n    }\r\n\r\n    // form curve outlines\r\n    reduced.forEach(function (segment) {\r\n      const slen = segment.length();\r\n      if (graduated) {\r\n        fcurves.push(\r\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\r\n        );\r\n        bcurves.push(\r\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\r\n        );\r\n      } else {\r\n        fcurves.push(segment.scale(d1));\r\n        bcurves.push(segment.scale(-d2));\r\n      }\r\n      alen += slen;\r\n    });\r\n\r\n    // reverse the \"return\" outline\r\n    bcurves = bcurves\r\n      .map(function (s) {\r\n        p = s.points;\r\n        if (p[3]) {\r\n          s.points = [p[3], p[2], p[1], p[0]];\r\n        } else {\r\n          s.points = [p[2], p[1], p[0]];\r\n        }\r\n        return s;\r\n      })\r\n      .reverse();\r\n\r\n    // form the endcaps as lines\r\n    const fs = fcurves[0].points[0],\r\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\r\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\r\n      be = bcurves[0].points[0],\r\n      ls = utils.makeline(bs, fs),\r\n      le = utils.makeline(fe, be),\r\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\r\n\r\n    return this.outl = new PolyBezier(segments);\r\n  }\r\n\r\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\r\n    d2 = d2 || d1;\r\n    const outline = this.outline(d1, d2).curves;\r\n    const shapes = [];\r\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\r\n      const shape = utils.makeshape(\r\n        outline[i],\r\n        outline[len - i],\r\n        curveIntersectionThreshold\r\n      );\r\n      shape.startcap.virtual = i > 1;\r\n      shape.endcap.virtual = i < len / 2 - 1;\r\n      shapes.push(shape);\r\n    }\r\n    return this.shapeoutl = shapes;\r\n  }\r\n\r\n  intersects(curve, curveIntersectionThreshold) {\r\n    if (!curve) return this.intersections.self = this.selfintersects(curveIntersectionThreshold);;\r\n    if (curve.p1 && curve.p2) {\r\n      return this.intersections.line = this.lineIntersects(curve);\r\n    }\r\n    if (curve instanceof Bezier) {\r\n      curve = curve.reduce();\r\n    }\r\n    return this.intersections.curve = this.curveintersects(\r\n      this.reduce(),\r\n      curve,\r\n      curveIntersectionThreshold\r\n    );\r\n  }\r\n\r\n  lineIntersects(line) {\r\n    const mx = min(line.p1.x, line.p2.x),\r\n      my = min(line.p1.y, line.p2.y),\r\n      MX = max(line.p1.x, line.p2.x),\r\n      MY = max(line.p1.y, line.p2.y);\r\n    return utils.roots(this.points, line).filter((t) => {\r\n      var p = this.get(t);\r\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\r\n    });\r\n  }\r\n\r\n  selfintersects(curveIntersectionThreshold) {\r\n    // \"simple\" curves cannot intersect with their direct\r\n    // neighbour, so for each segment X we check whether\r\n    // it intersects [0:x-2][x+2:last].\r\n\r\n    const reduced = this.reduce(),\r\n      len = reduced.length - 2,\r\n      results = [];\r\n\r\n    for (let i = 0, result, left, right; i < len; i++) {\r\n      left = reduced.slice(i, i + 1);\r\n      right = reduced.slice(i + 2);\r\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\r\n      results.push(...result);\r\n    }\r\n    return results;\r\n  }\r\n\r\n  curveintersects(c1, c2, curveIntersectionThreshold) {\r\n    const pairs = [];\r\n    // step 1: pair off any overlapping segments\r\n    c1.forEach(function (l) {\r\n      c2.forEach(function (r) {\r\n        if (l.overlaps(r)) {\r\n          pairs.push({ left: l, right: r });\r\n        }\r\n      });\r\n    });\r\n    // step 2: for each pairing, run through the convergence algorithm.\r\n    let intersections = [];\r\n    pairs.forEach(function (pair) {\r\n      const result = utils.pairiteration(\r\n        pair.left,\r\n        pair.right,\r\n        curveIntersectionThreshold\r\n      );\r\n      if (result.length > 0) {\r\n        intersections = intersections.concat(result);\r\n      }\r\n    });\r\n    return intersections;\r\n  }\r\n\r\n  arcs(errorThreshold) {\r\n    errorThreshold = errorThreshold || 0.5;\r\n    return this.carcs = this._iterate(errorThreshold, []);\r\n  }\r\n\r\n  _error(pc, np1, s, e) {\r\n    const q = (e - s) / 4,\r\n      c1 = this.get(s + q),\r\n      c2 = this.get(e - q),\r\n      ref = utils.dist(pc, np1),\r\n      d1 = utils.dist(pc, c1),\r\n      d2 = utils.dist(pc, c2);\r\n    return abs$1(d1 - ref) + abs$1(d2 - ref);\r\n  }\r\n\r\n  _iterate(errorThreshold, circles) {\r\n    let t_s = 0,\r\n      t_e = 1,\r\n      safety;\r\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\r\n    do {\r\n      safety = 0;\r\n\r\n      // step 1: start with the maximum possible arc\r\n      t_e = 1;\r\n\r\n      // points:\r\n      let np1 = this.get(t_s),\r\n        np2,\r\n        np3,\r\n        arc,\r\n        prev_arc;\r\n\r\n      // booleans:\r\n      let curr_good = false,\r\n        prev_good = false,\r\n        done;\r\n\r\n      // numbers:\r\n      let t_m = t_e,\r\n        prev_e = 1;\r\n\r\n      // step 2: find the best possible arc\r\n      do {\r\n        prev_good = curr_good;\r\n        prev_arc = arc;\r\n        t_m = (t_s + t_e) / 2;\r\n\r\n        np2 = this.get(t_m);\r\n        np3 = this.get(t_e);\r\n\r\n        arc = utils.getccenter(np1, np2, np3);\r\n\r\n        //also save the t values\r\n        arc.interval = {\r\n          start: t_s,\r\n          end: t_e,\r\n        };\r\n\r\n        let error = this._error(arc, np1, t_s, t_e);\r\n        curr_good = error <= errorThreshold;\r\n\r\n        done = prev_good && !curr_good;\r\n        if (!done) prev_e = t_e;\r\n\r\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\r\n        if (curr_good) {\r\n          // if e is already at max, then we're done for this arc.\r\n          if (t_e >= 1) {\r\n            // make sure we cap at t=1\r\n            arc.interval.end = prev_e = 1;\r\n            prev_arc = arc;\r\n            // if we capped the arc segment to t=1 we also need to make sure that\r\n            // the arc's end angle is correct with respect to the bezier end point.\r\n            if (t_e > 1) {\r\n              let d = {\r\n                x: arc.x + arc.r * cos$1(arc.e),\r\n                y: arc.y + arc.r * sin$1(arc.e),\r\n              };\r\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\r\n            }\r\n            break;\r\n          }\r\n          // if not, move it up by half the iteration distance\r\n          t_e = t_e + (t_e - t_s) / 2;\r\n        } else {\r\n          // this is a bad arc: we need to move 'e' down to find a good arc\r\n          t_e = t_m;\r\n        }\r\n      } while (!done && safety++ < 100);\r\n\r\n      if (safety >= 100) {\r\n        break;\r\n      }\r\n\r\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\r\n\r\n      prev_arc = prev_arc ? prev_arc : arc;\r\n      circles.push(prev_arc);\r\n      t_s = prev_e;\r\n    } while (t_e < 1);\r\n    return circles;\r\n  }\r\n}\r\n\r\nexport { Bezier };\r\n"],"names":["t","t2","min","max","a","b","c","d","v1","q","point","pi","ls","le","segments","tlen","alen"],"mappings":"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"}