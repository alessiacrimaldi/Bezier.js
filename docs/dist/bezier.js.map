{"version":3,"file":"bezier.js","sources":["../lib/bezier.js"],"sourcesContent":["/**\n  A javascript Bezier curve library\n**/\n\n// math-inlining.\nconst { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\n\n// cube root function yielding real roots\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n}\n\n// trig constants\nconst pi = Math.PI,\n  tau = 2 * pi,\n  quart = pi / 2,\n  // float precision significant decimal\n  epsilon = 0.000001,\n  // extremas used in bbox calculation and similar algorithms\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  // a zero coordinate, which is surprisingly useful\n  ZERO = { x: 0, y: 0, z: 0 };\n\n// Bezier utility functions\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [\n    -0.0640568928626056260850430826247450385909,\n    0.0640568928626056260850430826247450385909,\n    -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404,\n    -0.3150426796961633743867932913198102407864,\n    0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524,\n    0.4337935076260451384870842319133497124524,\n    -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107,\n    -0.6480936519369755692524957869107476266696,\n    0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232,\n    0.7401241915785543642438281030999784255232,\n    -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761,\n    -0.8864155270044010342131543419821967550873,\n    0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548,\n    0.9382745520027327585236490017087214496548,\n    -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411,\n    -0.9951872199970213601799974097007368118745,\n    0.9951872199970213601799974097007368118745,\n  ],\n\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [\n    0.1279381953467521569740561652246953718517,\n    0.1279381953467521569740561652246953718517,\n    0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264,\n    0.121670472927803391204463153476262425607,\n    0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622,\n    0.1155056680537256013533444839067835598622,\n    0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946,\n    0.0976186521041138882698806644642471544279,\n    0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185,\n    0.086190161531953275917185202983742667185,\n    0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193,\n    0.0592985849154367807463677585001085845412,\n    0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593,\n    0.0442774388174198061686027482113382288593,\n    0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491,\n    0.0123412297999871995468056670700372915759,\n    0.0123412297999871995468056670700372915759,\n  ],\n\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points;\n\n    // constant?\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    }\n\n    // linear?\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n      return ret;\n    }\n\n    // quadratic/cubic curve?\n    if (order < 4) {\n      let mt2 = mt * mt,\n        t2 = t * t,\n        a,\n        b,\n        c,\n        d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return ret;\n    }\n\n    // higher order curves: use de Casteljau's computation\n    const dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,\n        };\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n      r = ratios,\n      p = points;\n\n    let f1 = r[0],\n      f2 = r[1],\n      f3 = r[2],\n      f4 = r[3],\n      d;\n\n    // spec for linear\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to quadratic\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to cubic\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d\n          ? false\n          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t,\n      };\n    }\n  },\n\n  derive: function (points, _3d) {\n    const dpoints = [];\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y),\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n\n  between: function (v, m, M) {\n    return (\n      (m <= v && v <= M) ||\n      utils.approximately(v, m) ||\n      utils.approximately(v, M)\n    );\n  },\n\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n\n  length: function (derivativeFn) {\n    const z = 0.5,\n      len = utils.Tvalues.length;\n\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n    return z * sum;\n  },\n\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n      d2 = te - ts,\n      v2 = v - ds,\n      r = v2 / d1;\n    return ts + d2 * r;\n  },\n\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y),\n    };\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n\n  pointToString: function (p) {\n    let s = p.x + \"/\" + p.y;\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n    return s;\n  },\n\n  pointsToString: function (points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n      dy1 = v1.y - o.y,\n      dx2 = v2.x - o.x,\n      dy2 = v2.y - o.y,\n      cross = dx1 * dy2 - dy1 * dx2,\n      dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n      dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n      mpos,\n      d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist: mdist, mpos: mpos };\n  },\n\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const bottom = pow(t, n) + pow(1 - t, n),\n      top = bottom - 1;\n    return abs(top / bottom);\n  },\n\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const top = pow(1 - t, n),\n      bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx =\n      (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return { x: nx / d, y: ny / d };\n  },\n\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      x3 = p3.x,\n      y3 = p3.y,\n      x4 = p4.x,\n      y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n\n  makeline: function (p1, p2) {\n    return new Bezier(\n      p1.x,\n      p1.y,\n      (p1.x + p2.x) / 2,\n      (p1.y + p2.y) / 2,\n      p2.x,\n      p2.y\n    );\n  },\n\n  findbbox: function (sections) {\n    let mx = nMax,\n      my = nMax,\n      MX = nMin,\n      MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },\n    };\n  },\n\n  shapeintersections: function (\n    s1,\n    bbox1,\n    s2,\n    bbox2,\n    curveIntersectionThreshold\n  ) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end]),\n    };\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(\n        shape,\n        shape.bbox,\n        s2,\n        s2.bbox,\n        curveIntersectionThreshold\n      );\n    };\n    return shape;\n  },\n\n  getminmax: function (curve, d, list) {\n    if (!list) return { min: 0, max: 0 };\n    let min = nMax,\n      max = nMin,\n      t,\n      c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\n  },\n\n  align: function (points, line) {\n    const tx = line.p1.x,\n      ty = line.p1.y,\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\n      d = function (v) {\n        return {\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),\n        };\n      };\n    return points.map(d);\n  },\n\n  roots: function (points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n        b = aligned[1].y,\n        c = aligned[2].y,\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n      return [];\n    }\n\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n    const pa = aligned[0].y,\n      pb = aligned[1].y,\n      pc = aligned[2].y,\n      pd = aligned[3].y;\n\n    let d = -pa + 3 * pb - 3 * pc + pd,\n      a = 3 * pa - 6 * pb + 3 * pc,\n      b = -3 * pa + 3 * pb,\n      c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        }\n        // linear solution:\n        return [-c / b].filter(reduce);\n      }\n      // quadratic solution:\n      const q = sqrt(b * b - 4 * a * c),\n        a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    }\n\n    // at this point, we know we need a cubic solution:\n\n    a /= d;\n    b /= d;\n    c /= d;\n\n    const p = (3 * b - a * a) / 3,\n      p3 = p / 3,\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n      q2 = q / 2,\n      discriminant = q2 * q2 + p3 * p3 * p3;\n\n    let u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n        mp33 = mp3 * mp3 * mp3,\n        r = sqrt(mp33),\n        t = -q / (2 * r),\n        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n        phi = acos(cosphi),\n        crtr = crt(r),\n        t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n        b = p[1],\n        c = p[2],\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n\n    // linear roots are even easier\n    if (p.length === 2) {\n      const a = p[0],\n        b = p[1];\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n      return [];\n    }\n\n    return [];\n  },\n\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n      dnm,\n      adk,\n      dk,\n      k = 0,\n      r = 0;\n\n    //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x'² + y'²)^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z')² + (z'x\" - z\"x')² + (x'y\" - x\"y')²)\n    //   k(t) = -------------------------------------------------------\n    //                     (x'² + y'² + z'²)^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(\n        pow(d.y * dd.z - dd.y * d.z, 2) +\n        pow(d.z * dd.x - dd.z * d.x, 2) +\n        pow(d.x * dd.y - dd.x * d.y, 2)\n      );\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n\n    k = num / dnm;\n    r = dnm / num;\n\n    // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return { k: k, r: r, dk: dk, adk: adk };\n  },\n\n  inflections: function (points) {\n    if (points.length < 4) return [];\n\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),\n      a = p[2].x * p[1].y,\n      b = p[3].x * p[1].y,\n      c = p[1].x * p[2].y,\n      d = p[3].x * p[2].y,\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n      v2 = 18 * (3 * a - b - 3 * c),\n      v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n      return [];\n    }\n\n    const trm = v2 * v2 - 4 * v1 * v3,\n      sq = Math.sqrt(trm),\n      d2 = 2 * v1;\n\n    if (utils.approximately(d2, 0)) return [];\n\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n\n  bboxoverlap: function (b1, b2) {\n    const dims = [\"x\", \"y\"],\n      len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n    return true;\n  },\n\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n      c2b = c2.bbox(),\n      r = 100000,\n      threshold = curveIntersectionThreshold || 0.5;\n\n    if (\n      c1b.x.size + c1b.y.size < threshold &&\n      c2b.x.size + c2b.y.size < threshold\n    ) {\n      return [\n        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +\n        \"/\" +\n        (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,\n      ];\n    }\n\n    let cc1 = c1.split(0.5),\n      cc2 = c2.split(0.5),\n      pairs = [\n        { left: cc1.left, right: cc2.left },\n        { left: cc1.left, right: cc2.right },\n        { left: cc1.right, right: cc2.right },\n        { left: cc1.right, right: cc2.left },\n      ];\n\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n\n    let results = [];\n\n    if (pairs.length === 0) return results;\n\n    pairs.forEach(function (pair) {\n      results = results.concat(\n        utils.pairiteration(pair.left, pair.right, threshold)\n      );\n    });\n\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n\n    return results;\n  },\n\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n      dy1 = p2.y - p1.y,\n      dx2 = p3.x - p2.x,\n      dy2 = p3.y - p2.y,\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n      // chord midpoints\n      mx1 = (p1.x + p2.x) / 2,\n      my1 = (p1.y + p2.y) / 2,\n      mx2 = (p2.x + p3.x) / 2,\n      my2 = (p2.y + p3.y) / 2,\n      // midpoint offsets\n      mx1n = mx1 + dx1p,\n      my1n = my1 + dy1p,\n      mx2n = mx2 + dx2p,\n      my2n = my2 + dy2p,\n      // intersection of these lines:\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n      r = utils.dist(arc, p1);\n\n    // arc start/end values, over mid point:\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\n      _;\n\n    // determine arc direction (cw/ccw correction)\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    // assign and done.\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n\n  numberSort: function (a, b) {\n    return a - b;\n  },\n};\n\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  // setJoinC_0() {\n  //   // to do --> se discordi, fare il punto medio\n    \n  //   for (let i=0; i<this.curves.length; i++) {\n  //     if ()\n  //   }\n  // }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return (\n      \"[\" +\n      this.curves\n        .map(function (curve) {\n          return utils.pointsToString(curve.points);\n        })\n        .join(\", \") +\n      \"]\"\n    );\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves\n      .map(function (v) {\n        return v.length();\n      })\n      .reduce(function (a, b) {\n        return a + b;\n      });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n}\n\n// math-inlining.\nconst { abs: abs$1, min, max, cos: cos$1, sin: sin$1, acos: acos$1, sqrt: sqrt$1 } = Math;\nconst pi$1 = Math.PI;\n\n/**\n * Bezier curve constructor.\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = [\"x\", \"y\"]);\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    // is this curve, practically speaking, a straight line?\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    const baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t, p) => t + abs$1(p.y), 0) < baselength / 50;\n\n    this._lut = [];\n\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps) {\n      return this._lut;\n    }\n    this._lut = [];\n    // n steps means n+1 points\n    steps++;\n    this._lut = [];\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt$1(d.x * d.x + d.y * d.y);\n    return { x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt$1(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt$1(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = sqrt$1(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs$1(acos$1(s)) < pi$1 / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs$1(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1;\n\n    // TODO: make this take curves with control points outside\n    //       of the start-end interval into account\n\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);\n    return new Bezier(\n      this.points.map((p, i) => ({\n        x: p.x + v.x * d[i],\n        y: p.y + v.y * d[i],\n      }))\n    );\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for non-linear degenerate curves.\n\n    const clockwise = this.clockwise;\n    const points = this.points;\n\n    if (this._linear) {\n      return this.translate(\n        this.normal(0),\n        distanceFn ? distanceFn(0) : d,\n        distanceFn ? distanceFn(1) : d\n      );\n    }\n\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n\n    // move all points by distance 'd' wrt the origin 'o',\n    // and move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt$1(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === undefined ? d1 : d2;\n\n    if (this._linear) {\n      // TODO: find the actual extrema, because they might\n      //       be before the start, or past the end.\n\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n\n      if (d3 === undefined) {\n        d3 = d1;\n        d4 = d2;\n      }\n\n      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };\n      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const fline = [s, mid, e];\n\n      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };\n      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const bline = [e, mid, s];\n\n      const ls = utils.makeline(bline[2], fline[0]);\n      const le = utils.makeline(fline[2], bline[0]);\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\n      return new PolyBezier(segments);\n    }\n\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return abs$1(d1 - ref) + abs$1(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos$1(arc.e),\n                y: arc.y + arc.r * sin$1(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\nexport { Bezier };\n"],"names":["abs","cos","sin","acos","atan2","sqrt","pow","crt","v","pi","tau","quart","epsilon","nMax","nMin","ZERO","utils","t","derivativeFn","d","l","points","_3d","order","mt","p","ret","mt2","t2","b","c","dCpts","i","ratios","r","f1","f2","f3","f4","dpoints","list","j","dpt","m","M","a","precision","len","sum","ds","de","ts","te","d1","d2","v2","v1","s","obj","o","dx1","dy1","dx2","dy2","cross","dot","pos","p1","p2","dx","dy","LUT","point","mdist","mpos","idx","bottom","top","x1","y1","x2","y2","x3","y3","x4","y4","nx","ny","p3","p4","Bezier","sections","mx","my","MX","MY","bbox","s1","bbox1","s2","bbox2","curveIntersectionThreshold","intersections","a1","a2","l1","l2","iss","forward","back","bpl","fpl","start","end","shape","curve","min","max","line","tx","ty","aligned","reduce","m1","m2","pa","pb","pc","pd","q","q2","discriminant","u1","mp3","mp33","cosphi","phi","crtr","t1","sd","kOnly","num","dnm","adk","dk","k","dd","qdsum","pk","nk","v3","trm","sq","b1","b2","dims","dim","_bbox","c1","c2","c1b","c2b","threshold","cc1","cc2","pairs","pair","results","dx1p","dy1p","dx2p","dy2p","mx1","my1","mx2","my2","mx1n","my1n","mx2n","my2n","arc","e","_","PolyBezier","curves","offset","abs$1","cos$1","sin$1","acos$1","sqrt$1","pi$1","coords","args","coordlen","newargs","higher","step","baselength","abc","S","B","E","selen","lx","ly","bx1","by1","bx2","by2","e1","e2","A","nc1","nc2","x","y","last","print","angle","u","um","C","steps","error","lut","hits","closest","ft","np","pim","r1","r2","q1","R","_p","pt","result","roots","mfn","extrema","lbbox","tbbox","n","nv","n1","n2","segment","pass1","pass2","distanceFn","clockwise","ov","rc","d3","d4","mid","fline","bline","ls","le","segments","reduced","fcurves","bcurves","alen","tlen","graduated","linearDistanceFunction","slen","fs","fe","bs","be","outline","shapes","left","right","errorThreshold","np1","ref","circles","t_s","t_e","safety","np2","np3","prev_arc","curr_good","prev_good","done","t_m","prev_e"],"mappings":"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"}